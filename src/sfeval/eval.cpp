#include "sfeval.hpp"


namespace Eval {


// Piece maps generated by copilot
static constexpr int MAP_PAWN[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    50, 50, 50, 50, 50, 50, 50, 50,
    10, 10, 20, 30, 30, 20, 10, 10,
    5,  5, 10, 25, 25, 10,  5,  5,
    0,  0,  0, 20, 20,  0,  0,  0,
    5, -5,-10,  0,  0,-10, -5,  5,
    5, 10, 10,-20,-20, 10, 10,  5,
    0,  0,  0,  0,  0,  0,  0,  0
};
static constexpr int MAP_KNIGHT[64] = {
    -50,-40,-30,-30,-30,-30,-40,-50,
    -40,-20,  0,  0,  0,  0,-20,-40,
    -30,  0, 10, 15, 15, 10,  0,-30,
    -30,  5, 15, 20, 20, 15,  5,-30,
    -30,  0, 15, 20, 20, 15,  0,-30,
    -30,  5, 10, 15, 15, 10,  5,-30,
    -40,-20,  0,  5,  5,  0,-20,-40,
    -50,-40,-30,-30,-30,-30,-40,-50
};
static constexpr int MAP_BISHOP[64] = {
    -20,-10,-10,-10,-10,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5, 10, 10,  5,  0,-10,
    -10,  5,  5, 10, 10,  5,  5,-10,
    -10,  0, 10, 10, 10, 10,  0,-10,
    -10, 10, 10, 10, 10, 10, 10,-10,
    -10,  5,  0,  0,  0,  0,  5,-10,
    -20,-10,-10,-10,-10,-10,-10,-20
};
static constexpr int MAP_ROOK[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    5, 10, 10, 10, 10, 10, 10,  5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    -5,  0,  0,  0,  0,  0,  0, -5,
    0,  0,  0,  5,  5,  0,  0,  0
};
static constexpr int MAP_QUEEN[64] = {
    -20,-10,-10, -5, -5,-10,-10,-20,
    -10,  0,  0,  0,  0,  0,  0,-10,
    -10,  0,  5,  5,  5,  5,  0,-10,
     -5,  0,  5,  5,  5,  5,  0, -5,
      0,  0,  5,  5,  5,  5,  0, -5,
    -10,  5,  5,  5,  5,  5,  0,-10,
    -10,  0,  5,  0,  0,  0,  0,-10,
    -20,-10,-10, -5, -5,-10,-10,-20
};
static constexpr int MAP_KING[64] = {
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -30,-40,-40,-50,-50,-40,-40,-30,
    -20,-30,-30,-40,-40,-30,-30,-20,
    -10,-20,-20,-20,-20,-20,-20,-10,
     20, 20,  0,  0,  0,  0, 20, 20,
     20, 30, 10,  0,  0, 10, 30, 20
};


/**
 * Checks if the game finished (checkmate, stalemate, draw).
 * @return  Large negative if black wins, large positive if white wins, 0 if draw.
 */
static inline int check_eog(bool turn, int move_count, int mydepth) {
    if (move_count == 0) {
        if (turn)
            return -MATE_SCORE + mydepth;
        else
            return MATE_SCORE - mydepth;
    }
    // TODO stalemate check
    return 123456789;   // No eog code.
}

static inline int material(const Position& pos) {
    int score = 0;
    score += 100 * (Bit::popcnt(pos.wp) - Bit::popcnt(pos.bp));
    score += 300 * (Bit::popcnt(pos.wn) - Bit::popcnt(pos.bn));
    score += 300 * (Bit::popcnt(pos.wb) - Bit::popcnt(pos.bb));
    score += 500 * (Bit::popcnt(pos.wr) - Bit::popcnt(pos.br));
    score += 900 * (Bit::popcnt(pos.wq) - Bit::popcnt(pos.bq));
    return score;
}

static inline int piece_map(const Position& pos) {
    int score = 0;
    for (int i = 0; i < 64; i++) {
        const int piece = pos.piece_at(i);
        if (piece == EMPTY)
            continue;

        const int sq = piece <= WK ? 63-i : i;  // Piece maps are reversed.
        const int mult = piece <= WK ? 1 : -1;
        int curr_score;
        switch (piece) {
            case WP: case BP: curr_score = MAP_PAWN[sq]; break;
            case WN: case BN: curr_score = MAP_KNIGHT[sq]; break;
            case WB: case BB: curr_score = MAP_BISHOP[sq]; break;
            case WR: case BR: curr_score = MAP_ROOK[sq]; break;
            case WQ: case BQ: curr_score = MAP_QUEEN[sq]; break;
            case WK: case BK: curr_score = MAP_KING[sq]; break;
        }
        score += curr_score * mult;
    }

    return score;
}

int eval(const Position& pos, int move_count, int mydepth) {
    const int eog = check_eog(pos.turn, move_count, mydepth);
    if (eog != 123456789)
        return eog;

    const int mat = material(pos);
    const int pm = piece_map(pos);

    return mat + 0.11*pm;
}

int eval_rel(const Position& pos, int move_count, int mydepth) {
    const int score = eval(pos, move_count, mydepth);
    return pos.turn ? score : -score;
}


}
